import RPi.GPIO as GPIO
import time
from timeit import default_timer
import random
from math import *
import sys
import copy

CMD_IDLE        = 0b10000000
CMD_RESETPULSE  = 0b10001000
CMD_WRPRBITS    = 0b10010000
CMDH_WRPRBITS   = 0b10010
CMD_SETSTARTACQ = 0b10011000
CMD_STARTCONPUL = 0b10100000
CMD_STARTROPUL  = 0b10101000
CMD_SETSELECT   = 0b10110000
CMD_RSTBPULSE   = 0b10111000
CMD_READSTATUS  = 0b11000000
CMDH_READSTATUS = 0b11000
CMD_LOOPBRFIFO  = 0b11110000
CMDH_LOOPBRFIFO = 0b11110
CMD_LOOPBACK    = 0b11111000
CMDH_LOOPBACK   = 0b11111

# Initialization of RPi Max10 Bus
def bus_init():
    global BUS_OUT
    global RW
    global ST
    global ACK
    global AD0, AD1, AD2
    GPIO.setup(BUS_OUT, GPIO.OUT)
    GPIO.setup(RW, GPIO.OUT)
    GPIO.setup(ST, GPIO.OUT)
    GPIO.setup(AD0, GPIO.OUT)
    GPIO.setup(AD1, GPIO.OUT)
    GPIO.setup(AD2, GPIO.OUT)
    GPIO.setup(ACK, GPIO.IN)
    GPIO.output(AD0, GPIO.LOW)
    GPIO.output(AD1, GPIO.LOW)
    GPIO.output(AD2, GPIO.LOW)
    bus_set_write_mode()
    return 0

# RPi Max10 bus in writing mode
def bus_set_write_mode():
    global BUS_OUT
    global bus_status
    global RW
    global ST

    GPIO.setup(BUS_OUT, GPIO.OUT)
    GPIO.setup(ACK, GPIO.IN)
    GPIO.output(RW, 0)
    GPIO.output(ST, 1)
    bus_status = 1
    return 0

# RPi Max10 bus in writing mode
def bus_set_read_mode():
    global BUS_OUT
    global bus_status

    GPIO.setup(BUS_OUT, GPIO.IN)
    GPIO.setup(ACK, GPIO.IN)
    GPIO.output(RW, 1)
    GPIO.output(ST, 1)
    bus_status = 0
    return 0

# Read command
def read_command():
    global bus_status
    global BUS_OUT
    global read_data_byte
    global AD0, AD1, AD2

    if(bus_status == 1):
        bus_set_read_mode()

    result = 0
    GPIO.output(AD0, GPIO.LOW)
    GPIO.output(AD1, GPIO.LOW)
    GPIO.output(AD2, GPIO.LOW)
    GPIO.output(ST, GPIO.LOW)
    GPIO.output(ST, GPIO.LOW)

    if(GPIO.input(ACK) != 0):
        if(debug):
            print 'No ACK received after ST -> 0 transition (Read)'
        return [False, 0]
    else:
        for i in range (0, 8):
            read_data_byte[i] = GPIO.input(BUS_OUT[i])
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(ST, GPIO.HIGH)
    if(GPIO.input(ACK) != 1):
        if(debug):
            print 'No ACK received after ST -> 1 transition (Read)'
        return [False, 0]
    for i in range(0,8):
        if(read_data_byte[i] == 1):
            result = result | (1 << (7 - i))
    return [ True, result]

# Send Command
def send_command(output_data):
    global bus_status
    global AD0, AD1, AD2

    DATA = convert_byte2bit(output_data)
    GPIO.output(AD0, GPIO.LOW)
    GPIO.output(AD1, GPIO.LOW)
    GPIO.output(AD2, GPIO.LOW)

    if(bus_status == 0):
        bus_set_write_mode()
    else:
        GPIO.output(RW, 0)

    GPIO.output(BUS_OUT, DATA)
    GPIO.output(ST, GPIO.LOW)
    GPIO.output(ST, GPIO.LOW)
    if(GPIO.input(ACK) != 0):
        if(debug):
            print 'No ACK received after ST -> 0 transition (Write)'
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(ST, GPIO.HIGH)
        return -1
    else:
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(RW, 1)

    return 0

# Write into the Max10 FIFO, on teststand
def write_local_fifo(output_data):
    global bus_status
    global AD0, AD1, AD2
    GPIO.output(AD0, GPIO.HIGH)
    GPIO.output(AD1, GPIO.LOW)
    GPIO.output(AD2, GPIO.LOW)
    global RW
    global BUS_OUT

    DATA = convert_byte2bit(output_data)

    if(bus_status == 0):
        bus_set_write_mode()
    else:
        GPIO.output(RW, 0)

    GPIO.output(BUS_OUT, DATA)
    GPIO.output(ST, GPIO.LOW)
    GPIO.output(ST, GPIO.LOW)
    if(GPIO.input(ACK) != 0):
        if(debug):
            print 'No ACK received after ST -> 0 transition (Write)'
        GPIO.output(ST, GPIO.HIGH)
        return -1

    else:
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(RW, 1)
    return 0

# Read from Max10 FIFO, on teststand
def read_local_fifo():
    global bus_status
    global BUS_OUT
    global read_data_byte
    global AD0, AD1, AD2
    global RW
    global BUS_OUT

    GPIO.output(AD0, GPIO.HIGH)
    GPIO.output(AD1, GPIO.LOW)
    GPIO.output(AD2, GPIO.LOW)

    if(bus_status == 1):
        bus_set_read_mode()

    result = 0
    GPIO.output(ST, GPIO.LOW)
    GPIO.output(ST, GPIO.LOW)

    if(GPIO.input(ACK) != 0):
        if(debug):
            print 'No ACK received after ST -> 0 transition (Read)'
        return [False, 0]
    else:
        for i in range (0, 8):
            read_data_byte[i] = GPIO.input(BUS_OUT[7-i])
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(ST, GPIO.HIGH)
    if(GPIO.input(ACK) != 1):
        if(debug):
            print 'No ACK received after ST-> 1 transition (Read)'
        return [False, 0]
    for i in range(0,8):
        if(read_data_byte[i] == 1):
            result = result | (1 << i)
    return [True, result]

# Read used word counter on Max10 FIFO, low part
def read_usedwl():
    global bus_status
    global BUS_OUT
    global read_data_byte
    global AD0, AD1, AD2

    GPIO.output(AD0, GPIO.LOW)
    GPIO.output(AD1, GPIO.HIGH)
    GPIO.output(AD2, GPIO.LOW)

    if(bus_status == 1):
        bus_set_read_mode()
    result = 0
    GPIO.output(ST, GPIO.LOW)
    GPIO.output(ST, GPIO.LOW)

    if(GPIO.input(ACK) != 0):
        if(debug):
            print 'No ACK received after ST -> 0 transition (Read)'
        return [False, 0]
    else:
        for i in range (0, 8):
            read_data_byte[i] = GPIO.input(BUS_OUT[7-i])
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(ST, GPIO.HIGH)
    if(GPIO.input(ACK) != 1):
        if(debug):
            print 'No ACK received after ST -> 1 transition (Read)'
        return [False, 0]
    for i in range(0,8):
        if(read_data_byte[i] == 1):
            result = result | (1 << i)
    return [True, result]

# Read used word counter on Max10 FIFO, high part
def read_usedwh():
    global bus_status
    global BUS_OUT
    global read_data_byte
    global AD0, AD1, AD2

    GPIO.output(AD0, GPIO.HIGH)
    GPIO.output(AD1, GPIO.HIGH)
    GPIO.output(AD2, GPIO.LOW)

    if(bus_status == 1):
        bus_set_read_mode()
    result = 0
    GPIO.output(ST, GPIO.LOW)
    GPIO.output(ST, GPIO.LOW)

    if(GPIO.input(ACK) != 0):
        if(debug):
            print 'No ACK received after ST -> 0 transition (Read)'
        return [False, 0]
    else:
        for i in range (0, 8):
            read_data_byte[i] = GPIO.input(BUS_OUT[7-i])
        GPIO.output(ST, GPIO.HIGH)
        GPIO.output(ST, GPIO.HIGH)
    if(GPIO.input(ACK) != 1):
        if(debug):
            print 'No ACK received after ST -> 1 transition (Read)'
        return [False, 0]
    for i in range(0,8):
        if(read_data_byte[i] == 1):
            result = result | (1 << i)
    return [True, result]

# Byte -> bits converter
def convert_byte2bit(i):
    bit7 = (i >> 7) & 1
    bit6 = (i >> 6) & 1
    bit5 = (i >> 5) & 1
    bit4 = (i >> 4) & 1
    bit3 = (i >> 3) & 1
    bit2 = (i >> 2) & 1
    bit1 = (i >> 1) & 1
    bit0 = i & 1

    return [bit7, bit6, bit5, bit4, bit3, bit2, bit1, bit0]

# Byte to decimal converter
def convert_byte2dec(byte):
    dec = 0
    for i in range (0,8):
        dec = dec + ( byte[i]<<(7-i) & 255)
    return dec

# Hexaboard Programmer Bit by Bit
def progbitbybit():
    global result
    result = []
    fin = open("prog_string.txt","r")

    for chip in range(0,4):
        fin.seek(0,0)
        for i in range(0,384):
            bit = int(fin.read(1))
            d = CMD_WRPRBITS | bit
            send_command(d)
            do = []
            do = read_command()
            result.append(do[1]&1)
    print result
    return(0)

# Hexaboard Programmer 3 bits by 3 bits
def programming(prog_string):
    global result
    temp = []
    binary_string = []
    fout = open("default_prog_string.txt","w")

    for k in range(0, 48):
        temp.append(prog_string[k])
    # First Iteration -> Default values are coming out
    for chip in range(0,4):
        for i in range(0, 384, 3):             # 48 * 8 = 384 bits
            j = i
            byte_index = j/8
            bit_index = j % 8
            bit1 = ((temp[byte_index]) >> (7-bit_index)) & 1
            j = i + 1
            byte_index = j/8
            bit_index = j % 8
            bit2 = ((temp[byte_index]) >> (7-bit_index)) & 1
            j = i + 2
            byte_index = j/8
            bit_index = j % 8
            bit3 = ((temp[byte_index]) >> (7-bit_index)) & 1
            bits = bit1 << 2 | bit2 <<1 | bit3
            if(debug == 1):
                print chip, i, bits
            d = CMD_WRPRBITS | bits
            send_command(d)
            do = []
            do = read_command()
            if(debug):
                print hex(do[1]), hex(do[1] & 7)
            result.append(do[1])
            for l in range (0,3):
                x = (do[1]>>(2-l))&1
                binary_string.append(x)
                fout.write(str(x))
    fout.close

    # Second iteration -> Rewritten data is coming out
    for chip in range(0,4):
        for i in range(0, 384, 3):             # 48 * 8 = 384 bits
            j = i
            byte_index = j/8
            bit_index = j % 8
            bit1 = ((temp[byte_index]) >> (7-bit_index)) & 1
            j = i + 1
            byte_index = j/8
            bit_index = j % 8
            bit2 = ((temp[byte_index]) >> (7-bit_index)) & 1
            j = i + 2
            byte_index = j/8
            bit_index = j % 8
            bit3 = ((temp[byte_index]) >> (7-bit_index)) & 1
            bits = bit1 << 2 | bit2 <<1 | bit3
            d = CMD_WRPRBITS | bits
            send_command(d)
            do = []
            do = read_command()
            result.append(do[1])
            if(debug == 1):
                print chip, i, hex(do[1]&7)
    return()

# Read raw data
def read_raw():
    global raw

    raw = [0] * 30790
    for i in range(0, 30787):
        raw[i] = read_local_fifo()[1]
    return(raw)

# Data Readout
def readout():
    global raw
    global ev

    for i in range(0,1924):
        for j in range(0,16):
            x = raw[1 + i*16 + j]
            x = x & 15
            for k in range(0,4):
                ev[k][i] = ev[k][i] | (((x >> (3 - k) ) & 1) << (15 - j))
    return()

def decode_channels():
    global dati
    global ev

    for chip in range(0,4):
        for ch in range(0, 64):
            for hit in range(0, 13):
                dati[chip][ch][hit] = ev[chip][hit*64+ch] & 0x7F


    return()


###################################################################

BUS_OUT = [19, 13, 21, 20, 24, 25, 16, 26]
RW   = 17
ST   = 18
ACK  = 23
AD0   = 4
AD1   = 27
AD2   = 22
GPIO.setmode(GPIO.BCM)
bus_status = 0
debug = 0
count_correct = 0
count_error   = 0
read_error    = 0
read_correct  = 0
read_data_byte = [0,0,0,0,0,0,0,0]
result = []
bus_init()
Local_FIFO_test = 1
acquisition = 1
raw = [0]*30790
dati = [[[0 for hit in range(0,13)] for ch in range(0, 64)] for chip in range(0,4)]
ev = [[0 for i in range(0,1924)] for j in range(0, 4)]


prog_string = [ 0xda, 0xab, 0xff, 0x32, 0xe0, 0xd5, 0x3f, 0xe7, 0xf8, 0xb0,
                0x40, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1f, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xe9, 0xd5, 0x22, 0x8a, 0x80, 0x25]

print "** Bus Initialization **"
bus_init()

print"** SK2CMS Slow-Control Programming **"
send_command(CMD_RESETPULSE)
send_command(CMD_SETSELECT | 1)   # set SELECT to 1
send_command(CMD_RSTBPULSE)   # SK2RSTB pulse

programming(prog_string)


sys.stdout.flush()
if(Local_FIFO_test):
    print "** Local FIFO test **"
    print read_usedwh()[1] * 256 + read_usedwl()[1]
    i = 0
    for i in range(0, 10):
        write_local_fifo(i)
        print "During write FIFO Loop test", read_usedwh()[1] * 256 + read_usedwl()[1]
    for i in range(0, 10):
        a = read_local_fifo()
        print "W: ", hex(i), "   R: ",hex(a[1])
    print "After read FIFO Loop test", read_usedwh()[1] * 256 + read_usedwl()[1]

print "** Hexaboard Read Status **"
send_command(CMD_READSTATUS)
status = read_command()
print "Hexaboard status:", hex(status[1])

i = 0
print "Start", acquisition, "acquisitions"
while(i < acquisition):
    send_command(CMD_RESETPULSE)
    send_command(CMD_SETSTARTACQ | 1)
    send_command(CMD_SETSTARTACQ)
    send_command(CMD_STARTCONPUL)
    time.sleep(0.003)
    send_command(CMD_STARTROPUL)
    sys.stdout.flush()
    time.sleep(0.5)
    print "FIFO used word after R/O:", read_usedwh()[1] * 256 + read_usedwl()[1]

    print "** Start decoding event **"
    raw = read_raw()
    readout()
    for i in range(0,832, 64):
        for j in range(0,64):
            print hex(ev[0][i+j]),
        print "\n"

    for i in range(832, 1664, 64):
        for j in range(0,64):
            print hex(ev[0][i+j]),
        print "\n"

    for i in range(1664, 1920, 64):
        for j in range(0,64):
            print hex(ev[0][i+j]),
        print "\n"

    for i in range(1920, 1924):
        print hex(ev[0][i]),

    print "\n"

    decode_channels()
    for chip in range(0,4):
        for el in dati[chip]:
            for k in el:
                print hex(k),
            print "\n",

print "** ReadOut process finished **"
